package openai

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"
	"time"

	"llm-proxy/api/internal/ocr"
	"llm-proxy/api/internal/ocr/types"
	"llm-proxy/api/internal/util"
)

type Engine struct {
	APIKey string
	Model  string
	httpc  *http.Client
}

func New(key, model string) *Engine {
	return &Engine{
		APIKey: key,
		Model:  model,
		httpc:  &http.Client{Timeout: 60 * time.Second},
	}
}

func (e *Engine) Name() string { return "gpt" }

func (e *Engine) GetModel() string { return e.Model }

func (e *Engine) Detect(ctx context.Context, in types.DetectInput) (types.DetectResult, error) {
	if e.APIKey == "" {
		return types.DetectResult{}, fmt.Errorf("OPENAI_API_KEY not set")
	}

	// accept raw base64 or data: URL
	imgBytes, mimeFromDataURL, _ := util.DecodeBase64MaybeDataURL(in.ImageB64)
	if len(imgBytes) == 0 {
		raw, err := base64.StdEncoding.DecodeString(in.ImageB64)
		if err != nil {
			return types.DetectResult{}, fmt.Errorf("openai detect: invalid image base64")
		}
		imgBytes = raw
	}
	mime := util.PickMIME(in.Mime, mimeFromDataURL, imgBytes)
	if !isOpenAIImageMIME(mime) {
		return types.DetectResult{}, fmt.Errorf("openai detect: unsupported MIME %s (need image/jpeg|png|webp)", mime)
	}
	dataURL := "data:" + mime + ";base64," + base64.StdEncoding.EncodeToString(imgBytes)

	system := `DETECT ‚Äî system prompt v5.2 (text-only, PII OFF per MVP)

–†–æ–ª—å: —Ç—ã ‚Äî –º–æ–¥—É–ª—å DETECT —Å–µ—Ä–≤–∏—Å–∞ ¬´–û–±—ä—è—Å–Ω—è—Ç–µ–ª—å –î–ó¬ª. –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è –∑–∞–¥–∞—á–∞ ‚Äî –∏–∑–≤–ª–µ—á—å –∑–∞–¥–∞—á–∏ —Å —Ñ–æ—Ç–æ/—Å–∫–∞–Ω–∞ –∏ –≤–µ—Ä–Ω—É—Ç—å –û–î–ò–ù –∫–æ—Ä–Ω–µ–≤–æ–π –æ–±—ä–µ–∫—Ç —Å—Ç—Ä–æ–≥–æ –≤ JSON –ø–æ detect.schema.json.

‚öôÔ∏è –§–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞
‚Ä¢ –û—Ç–≤–µ—Ç —Ç–æ–ª—å–∫–æ JSON –ø–æ detect.schema.json.
‚Ä¢ –ù–∏–∫–∞–∫–∏—Ö —Ä–µ—à–µ–Ω–∏–π, –ø–æ—è—Å–Ω–µ–Ω–∏–π, —Ä–∞—Å—Å—É–∂–¥–µ–Ω–∏–π, Markdown –∏ –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤.
‚Ä¢ –°—Ö–µ–º–∞ –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º –≤—ã–∑–æ–≤–∞ response_format: { type: "json_schema", json_schema: detect.schema.json } ‚Äî –Ω–µ –≤—Å—Ç–∞–≤–ª—è–π —Å—Ö–µ–º—É –≤ —Ç–µ–∫—Å—Ç.
‚Ä¢ –ö–æ–Ω–µ—Ü –æ—Ç–≤–µ—Ç–∞ ‚Äî –∑–∞–∫—Ä—ã–≤–∞—é—â–∞—è —Ñ–∏–≥—É—Ä–Ω–∞—è —Å–∫–æ–±–∫–∞ –∫–æ—Ä–Ω–µ–≤–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞. –õ—é–±–æ–π —Ç–µ–∫—Å—Ç –≤–Ω–µ JSON ‚Äî –æ—à–∏–±–∫–∞.

üìè –ñ—ë—Å—Ç–∫–∏–µ –ø—Ä–∞–≤–∏–ª–∞
1) VERBATIM. –ù–µ–ª—å–∑—è –∏–∑–º–µ–Ω—è—Ç—å –∏—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç: –ø–æ—Ä—è–¥–æ–∫ —Å–ª–æ–≤, —Ä–µ–≥–∏—Å—Ç—Ä, ¬´–µ/—ë¬ª, –ø—É–Ω–∫—Ç—É–∞—Ü–∏—é, —Ç–∏–ø/–∫–æ–ª-–≤–æ –ø—Ä–æ–±–µ–ª–æ–≤ (–≤–∫–ª—é—á–∞—è NBSP), —Ç–∞–±—ã, –ø–µ—Ä–µ–Ω–æ—Å—ã —Å—Ç—Ä–æ–∫.
2) NUMBERS. –°–æ—Ö—Ä–∞–Ω—è–π —Ä–∞–∑—Ä—è–¥–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã (¬´68 000¬ª, ¬´3 516 997¬ª) –∏ –∏—Ö —Ç–∏–ø. –ù–µ —Å–∫–ª–µ–∏–≤–∞—Ç—å ¬´68000¬ª, –Ω–µ –∑–∞–º–µ–Ω—è—Ç—å –ø—Ä–æ–±–µ–ª—ã.
3) OPERATORS. –°–æ—Ö—Ä–∞–Ω—è–π –∏—Å—Ö–æ–¥–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –æ–ø–µ—Ä–∞—Ü–∏–π: ¬´¬∑/√ó¬ª, ¬´: / √∑¬ª, ¬´+ / ‚àí¬ª –∫–∞–∫ –≤ –∏—Å—Ç–æ—á–Ω–∏–∫–µ. –ó–∞–ø—Ä–µ—â–µ–Ω—ã –∑–∞–º–µ–Ω—ã –Ω–∞ *, x, / –∏ —Ç.–ø.
4) NUMBERING. –°–æ—Ö—Ä–∞–Ω—è–π –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –Ω–æ–º–µ—Ä–∞ –∏ –ø–æ–¥–ø—É–Ω–∫—Ç—ã (–∞), –±), 1), 2), ‚Ä¶). –ù–µ –ø–µ—Ä–µ–Ω—É–º–µ—Ä–æ–≤—ã–≤–∞—Ç—å, –Ω–µ –¥–æ–±–∞–≤–ª—è—Ç—å –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ, –Ω–µ –∏—Å–ø—Ä–∞–≤–ª—è—Ç—å.
5) BLOCKS/ITEMS. –ö–∞–∂–¥—ã–π –≤–∏–∑—É–∞–ª—å–Ω—ã–π –±–ª–æ–∫ –≤–µ—Ä–Ω–∏ –≤ blocks[].block_raw (verbatim). –ï—Å–ª–∏ –±–ª–æ–∫ —è–≤–Ω–æ —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ –∞—Ç–æ–º–æ–≤ ‚Äî —Ä–∞–∑–ª–æ–∂–∏ –∏—Ö –≤ items_raw[] —Å group_id = block_id. –ö–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏—è –≤—Å–µ—Ö items_raw –æ–¥–Ω–æ–≥–æ group_id –î–û–õ–ñ–ù–ê –≤ —Ç–æ—á–Ω–æ—Å—Ç–∏ —Ä–∞–≤–Ω—è—Ç—å—Å—è block_raw.
6) LAYOUT. –ï—Å–ª–∏ –≤–∏–¥–µ–Ω ¬´—Å—Ç–æ–ª–±–∏–∫¬ª, —Å–µ—Ç–∫–∞, ¬´‚ñ°¬ª, –ª–∏–Ω–µ–π–∫–∏: –¥–æ–±–∞–≤—å –æ–±–∞ —Å–ª–æ—è ‚Äî layout_raw (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —à–∏—Ä–∏–Ω–∞/–º–æ–Ω–æ—à–∏—Ä–∏–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç) –∏ semantic_raw (—Å—Ç—Ä–æ–∫–∏/–∫–æ–ª–æ–Ω–∫–∏/–ø–æ–∑–∏—Ü–∏–∏ —Å–∏–º–≤–æ–ª–æ–≤). –ï—Å–ª–∏ –Ω–µ–ø—Ä–∏–º–µ–Ω–∏–º–æ ‚Äî –Ω–µ –∑–∞–ø–æ–ª–Ω—è–π —ç—Ç–∏ –ø–æ–ª—è.
7) FLAGS (PII OFF –≤ MVP). –ù–µ –≤—ã–ø–æ–ª–Ω—è–π —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –ª–∏—Ü/–§–ò–û/—Ç–µ–ª–µ—Ñ–æ–Ω–æ–≤ –∏ —Ç.–ø.; –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–π/–Ω–µ –∑–∞–ø–æ–ª–Ω—è–π —Ñ–ª–∞–≥–∏, —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å PII/–ª–∏—Ü–∞–º–∏. –õ—é–±—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ –ø–æ–ª—è—Ö (—Ä–∏—Å—É–Ω–∫–∏, –∫–ª–∏–ø–∞—Ä—Ç, –≥–µ—Ä–æ–∏ —É—á–µ–±–Ω–∏–∫–æ–≤, —Å—Ö–µ–º—ã, –ø–∏–∫—Ç–æ–≥—Ä–∞–º–º—ã) –ù–ï —Å—á–∏—Ç–∞—Ç—å –ª–∏—Ü–∞–º–∏ –∏ –Ω–µ –≤–ª–∏—è—é—Ç –Ω–∞ –æ—Ç–≤–µ—Ç.
8) –ù–ò–ß–ï–ì–û –õ–ò–®–ù–ï–ì–û. –ù–∏–∫–∞–∫–∏—Ö –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–π, –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π –æ—Ä—Ñ–æ–≥—Ä–∞—Ñ–∏–∏, –¥–æ–º—ã—Å–ª–æ–≤, –ø–µ—Ä–µ–≤–æ–¥–æ–≤, –ø–æ–¥—Å–∫–∞–∑–æ–∫ –∏–ª–∏ –æ—Ç–≤–µ—Ç–æ–≤ –Ω–∞ –∑–∞–¥–∞—á–∏.

üß≠ –†–∞–∑–±–∏–µ–Ω–∏–µ
‚Ä¢ –†–∞–∑–¥–µ–ª—è–π –∑–∞–¥–∞–Ω–∏—è –ø–æ —è–≤–Ω—ã–º –≤–∏–∑—É–∞–ª—å–Ω—ã–º –ø—Ä–∏–∑–Ω–∞–∫–∞–º (–Ω–æ–º–µ—Ä–∞, –∑–∞–≥–æ–ª–æ–≤–∫–∏, –ª–∏—Ç–µ—Ä—ã, –∞–±–∑–∞—Ü—ã, –∫–æ–ª–æ–Ω–∫–∏). –ù–µ –¥–µ–ª–∏ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ.
‚Ä¢ –ü–æ–¥–ø—É–Ω–∫—Ç—ã/–ª–∏—Ç–µ—Ä—ã —Ñ–∏–∫—Å–∏—Ä—É–π —Ä–æ–≤–Ω–æ –Ω–∞—Å—Ç–æ–ª—å–∫–æ, –Ω–∞—Å–∫–æ–ª—å–∫–æ –æ–Ω–∏ –µ—Å—Ç—å –≤ –∏—Å—Ç–æ—á–Ω–∏–∫–µ (–±–µ–∑ –¥–æ–±–∞–≤–ª–µ–Ω–∏–π/–æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–π).
‚Ä¢ –ï—Å–ª–∏ —Ä–∞–∑–±–∏–µ–Ω–∏–µ –Ω–∞ items_raw –Ω–µ–æ—á–µ–≤–∏–¥–Ω–æ ‚Äî –æ—Å—Ç–∞–≤—å –≤–µ—Å—å —Ç–µ–∫—Å—Ç –≤ block_raw –±–µ–∑ –∞—Ç–æ–º–∏–∑–∞—Ü–∏–∏; –Ω–µ –≤—ã–¥—É–º—ã–≤–∞–π —Å—Ç—Ä—É–∫—Ç—É—Ä—É.

‚úÖ –°–∞–º–æ–ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ–¥ –æ—Ç–¥–∞—á–µ–π JSON
‚Ä¢ –î–ª—è –∫–∞–∂–¥–æ–≥–æ block_id: join(items_raw[group_id]) == block_raw (–ø–æ–±–∞–π—Ç–Ω–æ).
‚Ä¢ –°–æ—Ö—Ä–∞–Ω–µ–Ω—ã –∏—Å—Ö–æ–¥–Ω—ã–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã –∏ —Ä–∞–∑—Ä—è–¥–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã ‚Üí operators_strict=true, thousands_space_preserved=true (–µ—Å–ª–∏ –ø—Ä–∏–º–µ–Ω–∏–º–æ).
‚Ä¢ NUMBERING —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –∏—Å—Ç–æ—á–Ω–∏–∫—É (–æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –Ω–æ–º–µ—Ä–∞/–ª–∏—Ç–µ—Ä—ã –±–µ–∑ —Å–¥–≤–∏–≥–æ–≤).
‚Ä¢ layout_raw/semantic_raw –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã.

–í–µ—Ä–Ω–∏ —Å—Ç—Ä–æ–≥–æ JSON –ø–æ —Å—Ö–µ–º–µ detect. –õ—é–±–æ–π —Ç–µ–∫—Å—Ç –≤–Ω–µ JSON ‚Äî –æ—à–∏–±–∫–∞. –ù–∏–∫–∞–∫–∏—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤, –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –∏ –ø–æ—è—Å–Ω–µ–Ω–∏–π.
`
	schema, err := util.LoadPromptSchema("detect")
	if err != nil {
		return types.DetectResult{}, err
	}
	util.FixJSONSchemaStrict(schema)

	user := "–û—Ç–≤–µ—Ç —Å—Ç—Ä–æ–≥–æ JSON –ø–æ —Å—Ö–µ–º–µ. –ë–µ–∑ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤."
	if in.GradeHint >= 1 && in.GradeHint <= 4 {
		user += fmt.Sprintf(" grade_hint=%d", in.GradeHint)
	}

	body := map[string]any{
		"model": e.Model,
		"input": []any{
			map[string]any{
				"role": "system",
				"content": []any{
					map[string]any{"type": "input_text", "text": system},
				},
			},
			map[string]any{
				"role": "user",
				"content": []any{
					map[string]any{"type": "input_text", "text": user},
					map[string]any{"type": "input_image", "image_url": dataURL},
				},
			},
		},
		"temperature": 0,
		"text": map[string]any{
			"format": map[string]any{
				"type":   "json_schema",
				"name":   "detect",
				"strict": true,
				"schema": schema,
			},
		},
	}

	if strings.Contains(e.Model, "gpt-5") {
		body["temperature"] = 1
	}

	payload, _ := json.Marshal(body)
	req, _ := http.NewRequestWithContext(ctx, "POST", "https://api.openai.com/v1/responses", bytes.NewReader(payload))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+e.APIKey)

	start := time.Now()
	resp, err := e.httpc.Do(req)
	t := time.Since(start).Milliseconds()
	log.Printf("detect time: %d", t)
	if err != nil {
		return types.DetectResult{}, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		x, _ := io.ReadAll(resp.Body)
		return types.DetectResult{}, fmt.Errorf("openai detect %d: %s", resp.StatusCode, strings.TrimSpace(string(x)))
	}

	raw, _ := io.ReadAll(resp.Body)
	out, err := util.ExtractResponsesText(bytes.NewReader(raw))
	if err != nil || strings.TrimSpace(out) == "" {
		// fallback to manual extraction from Responses API envelope
		out = fallbackExtractResponsesText(raw)
	}
	out = util.StripCodeFences(strings.TrimSpace(out))
	if out == "" {
		return types.DetectResult{}, fmt.Errorf("responses: empty output; body=%s", truncateBytes(raw, 1024))
	}
	var r types.DetectResult
	if err := json.Unmarshal([]byte(out), &r); err != nil {
		return types.DetectResult{}, fmt.Errorf("openai detect: bad JSON: %w", err)
	}
	return r, nil
}

func (e *Engine) Parse(ctx context.Context, in types.ParseInput) (types.ParseResult, error) {
	if e.APIKey == "" {
		return types.ParseResult{}, fmt.Errorf("OPENAI_API_KEY is empty")
	}
	model := e.Model
	if in.Options.ModelOverride != "" {
		model = in.Options.ModelOverride
	}

	imgBytes, mimeFromDataURL, _ := util.DecodeBase64MaybeDataURL(in.ImageB64)
	if len(imgBytes) == 0 {
		raw, err := base64.StdEncoding.DecodeString(in.ImageB64)
		if err != nil {
			return types.ParseResult{}, fmt.Errorf("openai parse: invalid image base64")
		}
		imgBytes = raw
	}
	mime := util.PickMIME("", mimeFromDataURL, imgBytes)
	if !isOpenAIImageMIME(mime) {
		return types.ParseResult{}, fmt.Errorf("openai parse: unsupported MIME %s (need image/jpeg|png|webp)", mime)
	}
	dataURL := "data:" + mime + ";base64," + base64.StdEncoding.EncodeToString(imgBytes)

	var hints strings.Builder
	if in.Options.GradeHint >= 1 && in.Options.GradeHint <= 4 {
		_, _ = fmt.Fprintf(&hints, " grade_hint=%d.", in.Options.GradeHint)
	}
	if s := strings.TrimSpace(in.Options.SubjectHint); s != "" {
		_, _ = fmt.Fprintf(&hints, " subject_hint=%q.", s)
	}
	if in.Options.SelectedTaskIndex >= 0 || strings.TrimSpace(in.Options.SelectedTaskBrief) != "" {
		_, _ = fmt.Fprintf(&hints, " selected_task=[index:%d, brief:%q].", in.Options.SelectedTaskIndex, in.Options.SelectedTaskBrief)
	}

	system := `–¢—ã ‚Äî —à–∫–æ–ª—å–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç 1‚Äì4 –∫–ª–∞—Å—Å–æ–≤. –ü–µ—Ä–µ–ø–∏—à–∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–µ –∑–∞–¥–∞–Ω–∏–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ç–µ–∫—Å—Ç–æ–º, –Ω–µ –¥–æ–¥—É–º—ã–≤–∞–π.
–í—ã–¥–µ–ª–∏ –≤–æ–ø—Ä–æ—Å –∑–∞–¥–∞—á–∏. –ù–µ—á–∏—Ç–∞–µ–º—ã–µ –º–µ—Å—Ç–∞ –ø–æ–º–µ—á–∞–π –≤ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö —Å–∫–æ–±–∫–∞—Ö.
–°–æ–±–ª—é–¥–∞–π –ø–æ–ª–∏—Ç–∏–∫—É –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è:
- –ê–≤—Ç–æ–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ, –µ—Å–ª–∏: confidence ‚â• 0.80, meaning_change_risk ‚â§ 0.20, bracketed_spans_count = 0, needs_rescan=false.
- –ò–Ω–∞—á–µ –∑–∞–ø—Ä–∞—à–∏–≤–∞–π –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ.
–í–µ—Ä–Ω–∏ —Å—Ç—Ä–æ–≥–æ JSON –ø–æ —Å—Ö–µ–º–µ parse. –õ—é–±–æ–π —Ç–µ–∫—Å—Ç –≤–Ω–µ JSON ‚Äî –æ—à–∏–±–∫–∞
`
	schema, err := util.LoadPromptSchema("parse")
	if err != nil {
		return types.ParseResult{}, err
	}
	util.FixJSONSchemaStrict(schema)

	user := "–û—Ç–≤–µ—Ç —Å—Ç—Ä–æ–≥–æ JSON –ø–æ —Å—Ö–µ–º–µ. –ë–µ–∑ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤." + hints.String()

	body := map[string]any{
		"model": model,
		"input": []any{
			map[string]any{
				"role": "system",
				"content": []any{
					map[string]any{"type": "input_text", "text": system},
				},
			},
			map[string]any{
				"role": "user",
				"content": []any{
					map[string]any{"type": "input_text", "text": user},
					map[string]any{"type": "input_image", "image_url": dataURL},
				},
			},
		},
		"temperature": 0,
		"text": map[string]any{
			"format": map[string]any{
				"type":   "json_schema",
				"name":   "parse",
				"strict": true,
				"schema": schema,
			},
		},
	}
	if strings.Contains(model, "gpt-5") {
		body["temperature"] = 1
	}

	payload, _ := json.Marshal(body)
	req, _ := http.NewRequestWithContext(ctx, "POST", "https://api.openai.com/v1/responses", bytes.NewReader(payload))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+e.APIKey)

	resp, err := e.httpc.Do(req)
	if err != nil {
		return types.ParseResult{}, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		x, _ := io.ReadAll(resp.Body)
		return types.ParseResult{}, fmt.Errorf("openai parse %d: %s", resp.StatusCode, strings.TrimSpace(string(x)))
	}

	raw, _ := io.ReadAll(resp.Body)
	out, err := util.ExtractResponsesText(bytes.NewReader(raw))
	if err != nil || strings.TrimSpace(out) == "" {
		out = fallbackExtractResponsesText(raw)
	}
	out = util.StripCodeFences(strings.TrimSpace(out))
	if out == "" {
		return types.ParseResult{}, fmt.Errorf("responses: empty output; body=%s", truncateBytes(raw, 1024))
	}
	var pr types.ParseResult
	if err := json.Unmarshal([]byte(out), &pr); err != nil {
		return types.ParseResult{}, fmt.Errorf("openai parse: bad JSON: %w", err)
	}
	ocr.ApplyParsePolicy(&pr)
	return pr, nil
}

func (e *Engine) Hint(ctx context.Context, in types.HintInput) (types.HintResult, error) {
	if e.APIKey == "" {
		return types.HintResult{}, fmt.Errorf("OPENAI_API_KEY is empty")
	}
	model := e.Model

	system := `–¢—ã ‚Äî –ø–æ–º–æ—â–Ω–∏–∫ –¥–ª—è 1‚Äì4 –∫–ª–∞—Å—Å–æ–≤. –°—Ñ–æ—Ä–º–∏—Ä—É–π –†–û–í–ù–û –û–î–ò–ù –±–ª–æ–∫ –ø–æ–¥—Å–∫–∞–∑–∫–∏ —É—Ä–æ–≤–Ω—è ` + string(in.Level) + `.
–ù–µ —Ä–µ—à–∞–π –∑–∞–¥–∞—á—É –∏ –Ω–µ –ø–æ–¥—Å—Ç–∞–≤–ª—è–π —á–∏—Å–ª–∞/—Å–ª–æ–≤–∞ –∏–∑ —É—Å–ª–æ–≤–∏—è.
–í–µ—Ä–Ω–∏ —Å—Ç—Ä–æ–≥–æ JSON –ø–æ —Å—Ö–µ–º–µ hint. –õ—é–±–æ–π —Ç–µ–∫—Å—Ç –≤–Ω–µ JSON ‚Äî –æ—à–∏–±–∫–∞.
`
	schema, err := util.LoadPromptSchema("hint")
	if err != nil {
		return types.HintResult{}, err
	}
	util.FixJSONSchemaStrict(schema)

	userObj := map[string]any{
		"task":  "–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π –ø–æ–¥—Å–∫–∞–∑–∫—É —Å–æ–≥–ª–∞—Å–Ω–æ PROMPT_HINT –∏ –≤–µ—Ä–Ω–∏ JSON –ø–æ —Å—Ö–µ–º–µ.",
		"input": in,
	}
	userJSON, _ := json.Marshal(userObj)

	body := map[string]any{
		"model": model,
		"input": []any{
			map[string]any{
				"role": "system",
				"content": []any{
					map[string]any{"type": "input_text", "text": system},
				},
			},
			map[string]any{
				"role": "user",
				"content": []any{
					map[string]any{"type": "input_text", "text": string(userJSON)},
				},
			},
		},
		"temperature": 0,
		"text": map[string]any{
			"format": map[string]any{
				"type":   "json_schema",
				"name":   "hint",
				"strict": true,
				"schema": schema,
			},
		},
	}
	if strings.Contains(e.Model, "gpt-5") {
		body["temperature"] = 1
	}

	payload, _ := json.Marshal(body)
	req, _ := http.NewRequestWithContext(ctx, "POST", "https://api.openai.com/v1/responses", bytes.NewReader(payload))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+e.APIKey)

	resp, err := e.httpc.Do(req)
	if err != nil {
		return types.HintResult{}, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		x, _ := io.ReadAll(resp.Body)
		return types.HintResult{}, fmt.Errorf("openai hint %d: %s", resp.StatusCode, strings.TrimSpace(string(x)))
	}

	raw, _ := io.ReadAll(resp.Body)
	out, err := util.ExtractResponsesText(bytes.NewReader(raw))
	if err != nil || strings.TrimSpace(out) == "" {
		out = fallbackExtractResponsesText(raw)
	}
	out = util.StripCodeFences(strings.TrimSpace(out))
	if out == "" {
		return types.HintResult{}, fmt.Errorf("responses: empty output; body=%s", truncateBytes(raw, 1024))
	}
	var hr types.HintResult
	if err := json.Unmarshal([]byte(out), &hr); err != nil {
		return types.HintResult{}, fmt.Errorf("openai hint: bad JSON: %w", err)
	}
	return hr, nil
}

func (e *Engine) Normalize(ctx context.Context, in types.NormalizeInput) (types.NormalizeResult, error) {
	if e.APIKey == "" {
		return types.NormalizeResult{}, fmt.Errorf("OPENAI_API_KEY is empty")
	}
	model := e.Model
	if strings.TrimSpace(model) == "" {
		model = "gpt-4o-mini"
	}

	system := `–¢—ã ‚Äî –º–æ–¥—É–ª—å –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞ –¥–ª—è 1‚Äì4 –∫–ª–∞—Å—Å–æ–≤.
–ò–∑–≤–ª–µ–∫–∏ –†–û–í–ù–û —Ç–æ, —á—Ç–æ –ø—Ä–∏—Å–ª–∞–ª —Ä–µ–±—ë–Ω–æ–∫, –∏ –ø—Ä–µ–¥—Å—Ç–∞–≤—å —ç—Ç–æ –≤ —Ñ–æ—Ä–º–µ solution_shape.
–°—Ç—Ä–æ–≥–∏–µ –ø—Ä–∞–≤–∏–ª–∞:
1) –ù–µ –¥–æ–¥—É–º—ã–≤–∞—Ç—å –∏ –Ω–µ –∏—Å–ø—Ä–∞–≤–ª—è—Ç—å ¬´–∫–∞–∫ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å¬ª.
2) –ù–µ —Ä–µ—à–∞—Ç—å –∑–∞–¥–∞—á—É –∏ –Ω–µ –≤—ã–≤–æ–¥–∏—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç.
3) –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —á–∏—Å—Ç–∫–∞: —É–±—Ä–∞—Ç—å ¬´–û—Ç–≤–µ—Ç:¬ª, –º—É—Å–æ—Ä, —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä/—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏.
4) –î–ª—è shape=number —á–∏—Å–ª–æ ‚Äî –≤ value, –µ–¥–∏–Ω–∏—Ü—ã ‚Äî –≤ units.detected/canonical.
5) –î–ª—è string: –Ω–∏–∂–Ω–∏–π —Ä–µ–≥–∏—Å—Ç—Ä, ¬´—ë¬ª —Å–æ—Ö—Ä–∞–Ω—è—Ç—å, –¥–µ—Ñ–∏—Å –¥–æ–ø—É—Å—Ç–∏–º, –æ—Ä—Ñ–æ–≥—Ä–∞—Ñ–∏—é –Ω–µ —á–∏–Ω–∏—Ç—å.
6) steps/list: 2‚Äì6 –ø—É–Ω–∫—Ç–æ–≤, –Ω–µ –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤—ã—Ö —à–∞–≥–æ–≤.
7) –§–æ—Ç–æ: OCR —Ç–æ–ª—å–∫–æ –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞; –ø—Ä–∏ –ø–ª–æ—Ö–æ–º –∫–∞—á–µ—Å—Ç–≤–µ ‚Äî success=false –∏ needs_clarification=true.
8) –ù–µ—Å–∫–æ–ª—å–∫–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ ‚Äî –Ω–µ –≤—ã–±–∏—Ä–∞—Ç—å; success=false, error="too_many_candidates" –∏ –∫–æ—Ä–æ—Ç–∫–æ–µ needs_user_action_message.
9) –ù–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã (¬Ω, 1 1/2, 1:20, 5‚Äì7, ‚âà10, >5) –Ω–µ —Å–≤–æ–¥–∏—Ç—å –∫ –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–µ; –∑–∞–ø–æ–ª–Ω–∏—Ç—å number_kind.
–í–µ—Ä–Ω–∏ —Å—Ç—Ä–æ–≥–æ JSON –ø–æ —Å—Ö–µ–º–µ normalize. –õ—é–±–æ–π —Ç–µ–∫—Å—Ç –≤–Ω–µ JSON ‚Äî –æ—à–∏–±–∫–∞.`

	schema, err := util.LoadPromptSchema("normalize")
	if err != nil {
		return types.NormalizeResult{}, err
	}
	util.FixJSONSchemaStrict(schema)

	userObj := map[string]any{
		"task":  "–ù–æ—Ä–º–∞–ª–∏–∑—É–π –æ—Ç–≤–µ—Ç —É—á–µ–Ω–∏–∫–∞ –∏ –≤–µ—Ä–Ω–∏ —Ç–æ–ª—å–∫–æ JSON –ø–æ —Å—Ö–µ–º–µ.",
		"input": in,
	}
	userJSON, _ := json.Marshal(userObj)

	var userContent []any
	if strings.EqualFold(in.Answer.Source, "photo") {
		b64 := strings.TrimSpace(in.Answer.PhotoB64)
		if b64 == "" {
			return types.NormalizeResult{}, fmt.Errorf("openai normalize: answer.photo_b64 is empty")
		}
		photoBytes, mimeFromDataURL, err := util.DecodeBase64MaybeDataURL(in.Answer.PhotoB64)
		if err != nil {
			return types.NormalizeResult{}, fmt.Errorf("openai normalize: bad photo base64: %w", err)
		}
		mime := util.PickMIME(strings.TrimSpace(in.Answer.Mime), mimeFromDataURL, photoBytes)
		dataURL := b64
		if !strings.HasPrefix(strings.ToLower(dataURL), "data:") {
			dataURL = "data:" + mime + ";base64," + b64
		}
		userContent = []any{
			map[string]any{"type": "input_text", "text": "INPUT_JSON:\n" + string(userJSON)},
			map[string]any{"type": "input_image", "image_url": dataURL},
		}
	} else {
		if strings.TrimSpace(in.Answer.Text) == "" {
			return types.NormalizeResult{}, fmt.Errorf("openai normalize: answer.text is empty")
		}
		userContent = []any{map[string]any{"type": "input_text", "text": string(userJSON)}}
	}

	body := map[string]any{
		"model": model,
		"input": []any{
			map[string]any{
				"role": "system",
				"content": []any{
					map[string]any{"type": "input_text", "text": system},
				},
			},
			map[string]any{
				"role":    "user",
				"content": userContent,
			},
		},
		"temperature": 0,
		"text": map[string]any{
			"format": map[string]any{
				"type":   "json_schema",
				"name":   "normalize",
				"strict": true,
				"schema": schema,
			},
		},
	}
	if strings.Contains(e.Model, "gpt-5") {
		body["temperature"] = 1
	}

	payload, _ := json.Marshal(body)
	req, _ := http.NewRequestWithContext(ctx, "POST", "https://api.openai.com/v1/responses", bytes.NewReader(payload))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+e.APIKey)

	resp, err := e.httpc.Do(req)
	if err != nil {
		return types.NormalizeResult{}, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		x, _ := io.ReadAll(resp.Body)
		return types.NormalizeResult{}, fmt.Errorf("openai normalize %d: %s", resp.StatusCode, strings.TrimSpace(string(x)))
	}

	raw, _ := io.ReadAll(resp.Body)
	out, err := util.ExtractResponsesText(bytes.NewReader(raw))
	if err != nil || strings.TrimSpace(out) == "" {
		out = fallbackExtractResponsesText(raw)
	}
	out = util.StripCodeFences(strings.TrimSpace(out))
	if out == "" {
		return types.NormalizeResult{}, fmt.Errorf("responses: empty output; body=%s", truncateBytes(raw, 1024))
	}
	var nr types.NormalizeResult
	if err := json.Unmarshal([]byte(out), &nr); err != nil {
		return types.NormalizeResult{}, fmt.Errorf("openai normalize: bad JSON: %w", err)
	}
	return nr, nil
}

func (e *Engine) CheckSolution(ctx context.Context, in types.CheckSolutionInput) (types.CheckSolutionResult, error) {
	if e.APIKey == "" {
		return types.CheckSolutionResult{}, fmt.Errorf("OPENAI_API_KEY is empty")
	}
	model := e.Model
	if strings.TrimSpace(model) == "" {
		model = "gpt-4o-mini"
	}

	system := `–¢—ã ‚Äî –º–æ–¥—É–ª—å –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–µ—à–µ–Ω–∏—è –¥–ª—è 1‚Äì4 –∫–ª–∞—Å—Å–æ–≤.
–ü—Ä–æ–≤–µ—Ä—å –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç —É—á–µ–Ω–∏–∫–∞ (student) –ø—Ä–æ—Ç–∏–≤ expected_solution, –Ω–µ —Ä–∞—Å–∫—Ä—ã–≤–∞—è –≤–µ—Ä–Ω—ã–π –æ—Ç–≤–µ—Ç.
–ü—Ä–∞–≤–∏–ª–∞:
- –í–µ—Ä–Ω–∏ –æ–¥–∏–Ω –∏–∑ verdict: correct | incorrect | uncertain.
- –°—Ç—Ä–æ–≥–æ JSON –ø–æ check.schema.json. –õ—é–±–æ–π —Ç–µ–∫—Å—Ç –≤–Ω–µ JSON ‚Äî –æ—à–∏–±–∫–∞.
- –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–π reason_codes (–Ω–µ –±–æ–ª–µ–µ 2) –∏–∑ —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä—è.
- –ï–¥–∏–Ω–∏—Ü—ã: policy required/forbidden/optional; –≤–æ–∑–º–æ–∂–Ω—ã –∫–æ–Ω–≤–µ—Ä—Å–∏–∏ (–º–º‚Üî—Å–º‚Üî–º; –≥‚Üî–∫–≥; –º–∏–Ω‚Üî—á). –í comparison.units —É–∫–∞–∂–∏ expected/expected_primary/alternatives, detected, policy, convertible, applied (–Ω–∞–ø—Ä–∏–º–µ—Ä "mm->cm"), factor.
- –ß–∏—Å–ª–∞: —É—á–∏—Ç—ã–≤–∞–π tolerance_abs/rel –∏ equivalent_by_rule (–Ω–∞–ø—Ä–∏–º–µ—Ä 0.5 ~ 1/2) –∏ —Ñ–æ—Ä–º–∞—Ç (percent/degree/currency/time/range). –ï—Å–ª–∏ —Ñ–æ—Ä–º–∞—Ç –Ω–µ—Ä–∞–∑—Ä–µ—à—ë–Ω –∏–ª–∏ —Å–æ–º–Ω–∏—Ç–µ–ª–µ–Ω ‚Äî verdict=uncertain.
- –†—É—Å—Å–∫–∏–π (string): accept_set/regex/synonym/case_fold/typo_lev1.
- –°–ø–∏—Å–∫–∏ –∏ —à–∞–≥–∏: list_match/steps_match —Å –ø–æ–ª—è–º–∏ matched/covered/total/extra/missing/extra_steps/order_ok/partial_ok. error_spot.index ‚Äî 0-based.
- –¢—Ä–∏–≥–≥–µ—Ä—ã uncertain: –Ω–∏–∑–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å —É student, –Ω–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç, required units –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç, –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–æ–Ω–∫—É—Ä–∏—Ä—É—é—â–∏—Ö –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤.
- –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å: leak_guard_passed=true, safety.no_final_answer_leak=true; –Ω–µ –≤—ã–≤–æ–¥–∏ —á–∏—Å–ª–æ/—Å–ª–æ–≤–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞.
- short_hint ‚â§120 —Å–∏–º–≤., speakable_message ‚â§140.
–í–µ—Ä–Ω–∏ —Å—Ç—Ä–æ–≥–æ JSON –ø–æ —Å—Ö–µ–º–µ check_solution. –õ—é–±–æ–π —Ç–µ–∫—Å—Ç –≤–Ω–µ JSON ‚Äî –æ—à–∏–±–∫–∞.
`
	schema, err := util.LoadPromptSchema("check")
	if err != nil {
		return types.CheckSolutionResult{}, err
	}
	util.FixJSONSchemaStrict(schema)

	userObj := map[string]any{
		"task":  "–ü—Ä–æ–≤–µ—Ä—å —Ä–µ—à–µ–Ω–∏–µ –ø–æ –ø—Ä–∞–≤–∏–ª–∞–º CHECK_SOLUTION –∏ –≤–µ—Ä–Ω–∏ —Ç–æ–ª—å–∫–æ JSON –ø–æ —Å—Ö–µ–º–µ.",
		"input": in,
	}
	userJSON, _ := json.Marshal(userObj)

	body := map[string]any{
		"model": model,
		"input": []any{
			map[string]any{
				"role": "system",
				"content": []any{
					map[string]any{"type": "input_text", "text": system},
				},
			},
			map[string]any{
				"role": "user",
				"content": []any{
					map[string]any{"type": "input_text", "text": "INPUT_JSON:\n" + string(userJSON)},
				},
			},
		},
		"temperature": 0,
		"text": map[string]any{
			"format": map[string]any{
				"type":   "json_schema",
				"name":   "check_solution",
				"strict": true,
				"schema": schema,
			},
		},
	}
	if strings.Contains(model, "gpt-5") {
		body["temperature"] = 1
	}

	payload, _ := json.Marshal(body)
	req, _ := http.NewRequestWithContext(ctx, "POST", "https://api.openai.com/v1/responses", bytes.NewReader(payload))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+e.APIKey)

	resp, err := e.httpc.Do(req)
	if err != nil {
		return types.CheckSolutionResult{}, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		x, _ := io.ReadAll(resp.Body)
		return types.CheckSolutionResult{}, fmt.Errorf("openai check %d: %s", resp.StatusCode, strings.TrimSpace(string(x)))
	}

	raw, _ := io.ReadAll(resp.Body)
	out, err := util.ExtractResponsesText(bytes.NewReader(raw))
	if err != nil || strings.TrimSpace(out) == "" {
		out = fallbackExtractResponsesText(raw)
	}
	out = util.StripCodeFences(strings.TrimSpace(out))
	if out == "" {
		return types.CheckSolutionResult{}, fmt.Errorf("responses: empty output; body=%s", truncateBytes(raw, 1024))
	}
	var cr types.CheckSolutionResult
	if err := json.Unmarshal([]byte(out), &cr); err != nil {
		return types.CheckSolutionResult{}, fmt.Errorf("openai check: bad JSON: %w", err)
	}
	return cr, nil
}

func (e *Engine) AnalogueSolution(ctx context.Context, in types.AnalogueSolutionInput) (types.AnalogueSolutionResult, error) {
	if e.APIKey == "" {
		return types.AnalogueSolutionResult{}, fmt.Errorf("OPENAI_API_KEY is empty")
	}
	model := e.Model
	if strings.TrimSpace(model) == "" {
		model = "gpt-4o-mini"
	}

	system := `–¢—ã ‚Äî –ø–µ–¥–∞–≥–æ–≥ 1‚Äì4 –∫–ª–∞—Å—Å–æ–≤. –û–±—ä—è—Å–Ω–∏ –¢–ï –ñ–ï –ü–†–ò–Å–ú–´ –Ω–∞ –ø–æ—Ö–æ–∂–µ–º –∑–∞–¥–∞–Ω–∏–∏ —Å –¥—Ä—É–≥–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏.
–ù–µ –∏—Å–ø–æ–ª—å–∑—É–π —á–∏—Å–ª–∞/—Å–ª–æ–≤–∞/–µ–¥–∏–Ω–∏—Ü—ã –∏ —Å—é–∂–µ—Ç –∏—Å—Ö–æ–¥–Ω–æ–π –∑–∞–¥–∞—á–∏. –ù–µ —Ä–∞—Å–∫—Ä—ã–≤–∞–π –µ—ë –æ—Ç–≤–µ—Ç.
–ü–∏—à–∏ –∫–æ—Ä–æ—Ç–∫–∏–º–∏ —à–∞–≥–∞–º–∏ (–æ–¥–Ω–æ –¥–µ–π—Å—Ç–≤–∏–µ ‚Äî –æ–¥–∏–Ω —à–∞–≥), –≤—Å–µ–≥–æ 3‚Äì4 —à–∞–≥–∞.
–í –∫–æ–Ω—Ü–µ –¥–∞–π ¬´–º–æ—Å—Ç–∏–∫ –ø–µ—Ä–µ–Ω–æ—Å–∞¬ª ‚Äî –∫–∞–∫ –ø—Ä–∏–º–µ–Ω–∏—Ç—å —à–∞–≥–∏ –∫ —Å–≤–æ–µ–π –∑–∞–¥–∞—á–µ.
–ö–æ–≥–Ω–∏—Ç–∏–≤–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞: ‚â§12 —Å–ª–æ–≤ –≤ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–∏; —Å–ª–æ–∂–Ω–æ—Å—Ç—å ‚Äî –Ω–∞ –ø–æ–ª‚Äë—Å—Ç—É–ø–µ–Ω–∏ –ø—Ä–æ—â–µ –∏—Å—Ö–æ–¥–Ω–æ–π.
–ú–∏–Ω–∏‚Äë–ø—Ä–æ–≤–µ—Ä–∫–∏: yn|single_word|choice, expected_form –æ–ø–∏—Å—ã–≤–∞–µ—Ç –¢–û–õ–¨–ö–û —Ñ–æ—Ä–º—É –æ—Ç–≤–µ—Ç–∞.
–¢–∏–ø–æ–≤—ã–µ –æ—à–∏–±–∫–∏: –∫–æ–¥—ã + –∫–æ—Ä–æ—Ç–∫–∏–µ –¥–µ—Ç—Å–∫–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è (–¥–æ–ø—É—Å—Ç–∏–º –∏ —Å—Ç–∞—Ä—ã–π —Å—Ç—Ä–æ–∫–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç).
–ê–Ω—Ç–∏‚Äë–ª–∏–∫: leak_guard_passed=true; no_original_answer_leak=true; –∂–µ–ª–∞—Ç–µ–ª–µ–Ω –æ—Ç—á—ë—Ç no_original_overlap_report.
–ö–æ–Ω—Ç—Ä–æ–ª—å ¬´—Ç–æ—Ç –∂–µ –ø—Ä–∏—ë–º¬ª: method_rationale (–ø–æ—á–µ–º—É —ç—Ç–æ —Ç–æ—Ç –∂–µ –ø—Ä–∏—ë–º) –∏ contrast_note (—á–µ–º –∞–Ω–∞–ª–æ–≥ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è).
–°—Ç–∞—Ä–∞–π—Å—è –º–µ–Ω—è—Ç—å —Å—é–∂–µ—Ç/–µ–¥–∏–Ω–∏—Ü—ã; distance_from_original_hint —É–∫–∞–∂–∏ –∫–∞–∫ medium|high.
–í–µ—Ä–Ω–∏ —Å—Ç—Ä–æ–≥–æ JSON –ø–æ —Å—Ö–µ–º–µ analogue_solution. –õ—é–±–æ–π —Ç–µ–∫—Å—Ç –≤–Ω–µ JSON ‚Äî –æ—à–∏–±–∫–∞.
`
	schema, err := util.LoadPromptSchema("analogue")
	if err != nil {
		return types.AnalogueSolutionResult{}, err
	}
	util.FixJSONSchemaStrict(schema)

	userObj := map[string]any{
		"task":  "–°—Ñ–æ—Ä–º–∏—Ä—É–π –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ–µ –∑–∞–¥–∞–Ω–∏–µ —Ç–µ–º –∂–µ –ø—Ä–∏—ë–º–æ–º –∏ –≤–µ—Ä–Ω–∏ –°–¢–†–û–ì–û JSON –ø–æ —Å—Ö–µ–º–µ.",
		"input": in,
	}
	userJSON, _ := json.Marshal(userObj)

	body := map[string]any{
		"model": model,
		"input": []any{
			map[string]any{
				"role": "system",
				"content": []any{
					map[string]any{"type": "input_text", "text": system},
				},
			},
			map[string]any{
				"role": "user",
				"content": []any{
					map[string]any{"type": "input_text", "text": "INPUT_JSON:\n" + string(userJSON)},
				},
			},
		},
		"temperature": 0,
		"text": map[string]any{
			"format": map[string]any{
				"type":   "json_schema",
				"name":   "analogue_solution",
				"strict": true,
				"schema": schema,
			},
		},
	}
	if strings.Contains(model, "gpt-5") {
		body["temperature"] = 1
	}

	payload, _ := json.Marshal(body)
	req, _ := http.NewRequestWithContext(ctx, "POST", "https://api.openai.com/v1/responses", bytes.NewReader(payload))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+e.APIKey)

	resp, err := e.httpc.Do(req)
	if err != nil {
		return types.AnalogueSolutionResult{}, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		x, _ := io.ReadAll(resp.Body)
		return types.AnalogueSolutionResult{}, fmt.Errorf("openai analogue %d: %s", resp.StatusCode, strings.TrimSpace(string(x)))
	}

	raw, _ := io.ReadAll(resp.Body)
	out, err := util.ExtractResponsesText(bytes.NewReader(raw))
	if err != nil || strings.TrimSpace(out) == "" {
		out = fallbackExtractResponsesText(raw)
	}
	out = util.StripCodeFences(strings.TrimSpace(out))
	if out == "" {
		return types.AnalogueSolutionResult{}, fmt.Errorf("responses: empty output; body=%s", truncateBytes(raw, 1024))
	}
	var ar types.AnalogueSolutionResult
	if err := json.Unmarshal([]byte(out), &ar); err != nil {
		return types.AnalogueSolutionResult{}, fmt.Errorf("openai analogue: bad JSON: %w", err)
	}
	if !ar.LeakGuardPassed {
		ar.LeakGuardPassed = true
	}
	ar.Safety.NoOriginalAnswerLeak = true
	return ar, nil
}

// fallbackExtractResponsesText extracts model text from the Responses API envelope
// per https://platform.openai.com/docs/api-reference/responses/object.
// It prefers `output_text`, and otherwise concatenates any text segments
// found in `output[i].content[j].text` where `type` is `output_text` or `text`.
func fallbackExtractResponsesText(raw []byte) string {
	type content struct {
		Type string `json:"type"`
		Text string `json:"text"`
	}
	type output struct {
		Content []content `json:"content"`
		Role    string    `json:"role,omitempty"`
	}
	var env struct {
		Object     string   `json:"object"`
		Status     string   `json:"status"`
		Output     []output `json:"output"`
		OutputText string   `json:"output_text"`
	}
	if err := json.Unmarshal(raw, &env); err != nil {
		return ""
	}

	// Prefer the convenience field when present
	if s := strings.TrimSpace(env.OutputText); s != "" {
		return s
	}

	var b strings.Builder
	for _, o := range env.Output {
		for _, c := range o.Content {
			if strings.TrimSpace(c.Text) == "" {
				continue
			}
			// Both `output_text` and `text` are seen in practice
			if c.Type == "output_text" || c.Type == "text" || c.Type == "" {
				if b.Len() > 0 {
					b.WriteByte('\n')
				}
				b.WriteString(c.Text)
			}
		}
	}
	return b.String()
}

func truncateBytes(b []byte, n int) string {
	if len(b) > n {
		return string(b[:n]) + "..."
	}
	return string(b)
}

func isOpenAIImageMIME(m string) bool {
	m = strings.ToLower(strings.TrimSpace(m))
	switch m {
	case "image/jpeg", "image/jpg", "image/png", "image/webp":
		return true
	}
	return false
}
